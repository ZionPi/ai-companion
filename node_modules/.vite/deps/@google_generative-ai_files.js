import {
  __commonJS,
  __toESM
} from "./chunk-WXXH56N5.js";

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@google/generative-ai/dist/files/index.mjs
var import_fs = __toESM(require_fs(), 1);
var GoogleGenerativeAIError = class extends Error {
  constructor(message) {
    super(`[GoogleGenerativeAI Error]: ${message}`);
  }
};
var GoogleGenerativeAIFetchError = class extends GoogleGenerativeAIError {
  constructor(message, status, statusText, errorDetails) {
    super(message);
    this.status = status;
    this.statusText = statusText;
    this.errorDetails = errorDetails;
  }
};
var GoogleGenerativeAIRequestInputError = class extends GoogleGenerativeAIError {
};
var DEFAULT_BASE_URL = "https://generativelanguage.googleapis.com";
var DEFAULT_API_VERSION = "v1beta";
var PACKAGE_VERSION = "0.12.0";
var PACKAGE_LOG_HEADER = "genai-js";
var Task;
(function(Task2) {
  Task2["GENERATE_CONTENT"] = "generateContent";
  Task2["STREAM_GENERATE_CONTENT"] = "streamGenerateContent";
  Task2["COUNT_TOKENS"] = "countTokens";
  Task2["EMBED_CONTENT"] = "embedContent";
  Task2["BATCH_EMBED_CONTENTS"] = "batchEmbedContents";
})(Task || (Task = {}));
function getClientHeaders(requestOptions) {
  const clientHeaders = [];
  if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiClient) {
    clientHeaders.push(requestOptions.apiClient);
  }
  clientHeaders.push(`${PACKAGE_LOG_HEADER}/${PACKAGE_VERSION}`);
  return clientHeaders.join(" ");
}
var FilesTask;
(function(FilesTask2) {
  FilesTask2["UPLOAD"] = "upload";
  FilesTask2["LIST"] = "list";
  FilesTask2["GET"] = "get";
  FilesTask2["DELETE"] = "delete";
})(FilesTask || (FilesTask = {}));
var taskToMethod = {
  [FilesTask.UPLOAD]: "POST",
  [FilesTask.LIST]: "GET",
  [FilesTask.GET]: "GET",
  [FilesTask.DELETE]: "DELETE"
};
var FilesRequestUrl = class {
  constructor(task, apiKey, requestOptions) {
    var _a, _b;
    this.task = task;
    this.apiKey = apiKey;
    this.requestOptions = requestOptions;
    const apiVersion = ((_a = this.requestOptions) === null || _a === void 0 ? void 0 : _a.apiVersion) || DEFAULT_API_VERSION;
    const baseUrl = ((_b = this.requestOptions) === null || _b === void 0 ? void 0 : _b.baseUrl) || DEFAULT_BASE_URL;
    let initialUrl = baseUrl;
    if (this.task === FilesTask.UPLOAD) {
      initialUrl += `/upload`;
    }
    initialUrl += `/${apiVersion}/files`;
    this._url = new URL(initialUrl);
  }
  appendPath(path) {
    this._url.pathname = this._url.pathname + `/${path}`;
  }
  appendParam(key, value) {
    this._url.searchParams.append(key, value);
  }
  toString() {
    return this._url.toString();
  }
};
function getHeaders(url) {
  const headers = new Headers();
  headers.append("x-goog-api-client", getClientHeaders(url.requestOptions));
  headers.append("x-goog-api-key", url.apiKey);
  return headers;
}
async function makeFilesRequest(url, headers, body, fetchFn = fetch) {
  const requestInit = {
    method: taskToMethod[url.task],
    headers
  };
  if (body) {
    requestInit.body = body;
  }
  const signal = getSignal(url.requestOptions);
  if (signal) {
    requestInit.signal = signal;
  }
  try {
    const response = await fetchFn(url.toString(), requestInit);
    if (!response.ok) {
      let message = "";
      let errorDetails;
      try {
        const json = await response.json();
        message = json.error.message;
        if (json.error.details) {
          message += ` ${JSON.stringify(json.error.details)}`;
          errorDetails = json.error.details;
        }
      } catch (e) {
      }
      throw new GoogleGenerativeAIFetchError(`Error fetching from ${url.toString()}: [${response.status} ${response.statusText}] ${message}`, response.status, response.statusText, errorDetails);
    } else {
      return response;
    }
  } catch (e) {
    let err = e;
    if (!(e instanceof GoogleGenerativeAIFetchError)) {
      err = new GoogleGenerativeAIError(`Error fetching from ${url.toString()}: ${e.message}`);
      err.stack = e.stack;
    }
    throw err;
  }
}
function getSignal(requestOptions) {
  if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {
    const abortController = new AbortController();
    const signal = abortController.signal;
    setTimeout(() => abortController.abort(), requestOptions.timeout);
    return signal;
  }
}
var GoogleAIFileManager = class {
  constructor(apiKey, _requestOptions) {
    this.apiKey = apiKey;
    this._requestOptions = _requestOptions;
  }
  /**
   * Upload a file
   */
  async uploadFile(filePath, fileMetadata) {
    const file = (0, import_fs.readFileSync)(filePath);
    const url = new FilesRequestUrl(FilesTask.UPLOAD, this.apiKey, this._requestOptions);
    const uploadHeaders = getHeaders(url);
    const boundary = generateBoundary();
    uploadHeaders.append("X-Goog-Upload-Protocol", "multipart");
    uploadHeaders.append("Content-Type", `multipart/related; boundary=${boundary}`);
    const uploadMetadata = getUploadMetadata(fileMetadata);
    const metadataString = JSON.stringify({ file: uploadMetadata });
    const preBlobPart = "--" + boundary + "\r\nContent-Type: application/json; charset=utf-8\r\n\r\n" + metadataString + "\r\n--" + boundary + "\r\nContent-Type: " + fileMetadata.mimeType + "\r\n\r\n";
    const postBlobPart = "\r\n--" + boundary + "--";
    const blob = new Blob([preBlobPart, file, postBlobPart]);
    const response = await makeFilesRequest(url, uploadHeaders, blob);
    return response.json();
  }
  /**
   * List all uploaded files
   */
  async listFiles(listParams) {
    const url = new FilesRequestUrl(FilesTask.LIST, this.apiKey, this._requestOptions);
    if (listParams === null || listParams === void 0 ? void 0 : listParams.pageSize) {
      url.appendParam("pageSize", listParams.pageSize.toString());
    }
    if (listParams === null || listParams === void 0 ? void 0 : listParams.pageToken) {
      url.appendParam("pageToken", listParams.pageToken);
    }
    const uploadHeaders = getHeaders(url);
    const response = await makeFilesRequest(url, uploadHeaders);
    return response.json();
  }
  /**
   * Get metadata for file with given ID
   */
  async getFile(fileId) {
    const url = new FilesRequestUrl(FilesTask.GET, this.apiKey, this._requestOptions);
    url.appendPath(parseFileId(fileId));
    const uploadHeaders = getHeaders(url);
    const response = await makeFilesRequest(url, uploadHeaders);
    return response.json();
  }
  /**
   * Delete file with given ID
   */
  async deleteFile(fileId) {
    const url = new FilesRequestUrl(FilesTask.DELETE, this.apiKey, this._requestOptions);
    url.appendPath(parseFileId(fileId));
    const uploadHeaders = getHeaders(url);
    await makeFilesRequest(url, uploadHeaders);
  }
};
function parseFileId(fileId) {
  if (fileId.startsWith("files/")) {
    return fileId.split("files/")[1];
  }
  if (!fileId) {
    throw new GoogleGenerativeAIError(`Invalid fileId ${fileId}. Must be in the format "files/filename" or "filename"`);
  }
  return fileId;
}
function generateBoundary() {
  let str = "";
  for (let i = 0; i < 2; i++) {
    str = str + Math.random().toString().slice(2);
  }
  return str;
}
function getUploadMetadata(inputMetadata) {
  if (!inputMetadata.mimeType) {
    throw new GoogleGenerativeAIRequestInputError("Must provide a mimeType.");
  }
  const uploadMetadata = {
    mimeType: inputMetadata.mimeType,
    displayName: inputMetadata.displayName
  };
  if (inputMetadata.name) {
    uploadMetadata.name = inputMetadata.name.includes("/") ? inputMetadata.name : `files/${inputMetadata.name}`;
  }
  return uploadMetadata;
}
var FileState;
(function(FileState2) {
  FileState2["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
  FileState2["PROCESSING"] = "PROCESSING";
  FileState2["ACTIVE"] = "ACTIVE";
  FileState2["FAILED"] = "FAILED";
})(FileState || (FileState = {}));
export {
  FileState,
  GoogleAIFileManager
};
/*! Bundled license information:

@google/generative-ai/dist/files/index.mjs:
  (**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
//# sourceMappingURL=@google_generative-ai_files.js.map
